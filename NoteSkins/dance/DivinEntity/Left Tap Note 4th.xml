<ActorFrame
 InitCommand="%function(self)                
    DIVINE_ENTITY = {
        notes={},
        explosions={},
        receptors={[PLAYER_1]={}, [PLAYER_2]={}},
        receptorsLookupTable={},
        
        --some constants
        STATE_NEUTRAL = 1,
        STATE_PRESSED = 2,
        NOTE_TYPE_TAP = 'Tap Note',
        NOTE_TYPE_HOLD_HEAD_ACTIVE = 'Hold Head active',
        NOTE_TYPE_HOLD_HEAD_INACTIVE = 'Hold Head inactive',
        NOTE_TYPE_ROLL_HEAD_ACTIVE = 'Roll Head active',
        NOTE_TYPE_ROLL_HEAD_INACTIVE = 'Roll Head inactive',
        EXPLOSION_NOTE_TYPE_TAP = 'Tap',
        TNS_MARVELOUS='Fantastic',
        TNS_PERFECT='Excellent',
        TNS_GREAT='Great',
        TNS_GOOD='Decent',
        TNS_BOO='WayOff',
        TNS_MISS='Miss',
        TNS_HIT_MINE='HitMine',
        TNS_OK='OK',
        TNS_NG='NG'
    }
    
    --This function makes the fluent magic happen in getTapNotes, getExplosions and getReceptors.
    function DIVINE_ENTITY.catch(table, key)
        return function(...)
            local paramsToPassOn = {}
        
            tick = 1;
            for i,v in pairs(arg) do
                if type(v) ~= 'table' then
                    paramsToPassOn[tick] = v
                    tick = tick+1
                end
            end
         
            for i,v in pairs(arg[1]) do
                --This is the worst hack ever and I am not proud of it.
                _G['DivinEntity_f2r'] = v
                funcstr = '_G[\'DivinEntity_f2r\']:' .. key .. '(\'' .. unpack(paramsToPassOn) .. '\')';
                assert(loadstring(funcstr))()                                
            end
            
            return table
        end                    
    end

    --[[
    p1's stuff is loaded first. So registerReceptor will always
    be called from p1 first. Therefore it should be sufficient
    to check if we have a actor for p1. If we don't then this
    actor must be p1s, otherwise it is p2s.

    We also put the string value of the actor in a lookup table.
    This way, in the receptor xml files, all we have to do on a pressCommand
    is DIVINE_ENTITY:receptorPressed(self) and we can lookup what arrow that
    actor is, and broadcast accordingly.
    --]]
    function DIVINE_ENTITY:registerReceptor(direction, actor)
    
        --Case 1: P1 _XOR_ P2. We know exactly who the receptors belong to.
        if GAMESTATE:IsPlayerEnabled(PLAYER_1) and not GAMESTATE:IsPlayerEnabled(PLAYER_2) then
            self.receptors[PLAYER_1][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P1' .. direction, state = self.STATE_NEUTRAL}            
            return
        elseif not GAMESTATE:IsPlayerEnabled(PLAYER_1) and GAMESTATE:IsPlayerEnabled(PLAYER_2) then
            self.receptors[PLAYER_2][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P2' .. direction, state = self.STATE_NEUTRAL}
            return
        end
    
        --Case 2: P1 _AND_ P2. We don't know who the arrows belong to, need to be clever.
        if self.receptors[PLAYER_1][direction] == nil then
            self.receptors[PLAYER_1][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P1' .. direction, state = self.STATE_NEUTRAL}
        else
            self.receptors[PLAYER_2][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P2' .. direction, state = self.STATE_NEUTRAL}
        end
    end
    
    --[[
    Initially I wanted this to only return the Over and Under sprites. But there is a weird issue
    where those sprites do some strange stuff if they get far away from their initial position.
    
    So what this unfortunately means is this function behaves a bit different to the others.
    
    If you give it JUST a direction, it returns the actor frame, so it can be moved nicely.
    If you give it at least sprite, then it will return the sprite actor itself.
    If you give it nothing it returns all the actor frames.
    --]]
    function DIVINE_ENTITY:getReceptors(player, direction, sprite)
        local receptors = {}
        local mt = { __index = self.catch }

        setmetatable(receptors, mt)
        
        for name,actor in pairs(self.receptors[player]) do
            if direction and sprite then
                if string.find(name, direction .. ' ' .. sprite) then receptors[name] = actor end
            elseif direction then
                --return the frame not the two actors in it
                if name == direction then receptors[name] = actor end
            elseif sprite then
                --return the actor in the frame, not the frame it self. The actor frames all have names <= 5
                if string.find(name, sprite) and string.len(name) > 5 then receptors[name] = actor end
            else
                if string.len(name) <= 5 then receptors[name] = actor end
            end
        end

        return receptors
    end
    
    function DIVINE_ENTITY:receptorPressed(actor)
        local prefix = self.receptorsLookupTable[tostring(actor)].name
        self.receptorsLookupTable[tostring(actor)].state = self.STATE_PRESSED
        MESSAGEMAN:Broadcast('Step' .. prefix .. 'Pressed')
    end

    function DIVINE_ENTITY:receptorLifted(actor)
        local prefix = self.receptorsLookupTable[tostring(actor)].name
        self.receptorsLookupTable[tostring(actor)].state = self.STATE_NEUTRAL
        MESSAGEMAN:Broadcast('Step' .. prefix .. 'Lifted')
    end

    function DIVINE_ENTITY:isReceptorPressed(direction, player)
        local actor = self.receptors[player][direction]
        return self.receptorsLookupTable[tostring(actor)].state == self.STATE_PRESSED
    end
    
    function DIVINE_ENTITY:getReceptorState(direction, player)
        local actor = self.receptors[player][direction]        
        return self.receptorsLookupTable[tostring(actor)].state
    end
    
    function DIVINE_ENTITY:receptorHitNote(actor, TNS)
        local prefix = string.sub(self.receptorsLookupTable[tostring(actor)].name, 1, 2)
        Trace('Broadcasting: ' .. prefix .. TNS)
        MESSAGEMAN:Broadcast(prefix .. TNS)
    end
    
    function DIVINE_ENTITY:registerNote (noteType, name, actor)
        if self.notes[noteType] == nil then
            self.notes[noteType] = {}
        end

        self.notes[noteType][name] = actor
    end
	
    function DIVINE_ENTITY:getNotes(noteType, direction, quant)
        local direction = direction or ''
        local quant = quant or ''
        
        local arrows = {}
        local mt = { __index = self.catch }

        setmetatable(arrows, mt)

        --No string.match in Lua 5.0 :[
        for name,actor in pairs(self.notes[noteType]) do
            if direction and quant then
                if string.find(name, direction .. ' ' .. noteType .. ' ' .. quant) then arrows[name] = actor end
            end
        end    

        return arrows
    end
       
    function DIVINE_ENTITY:registerTapNote(name, actor)
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_TAP, name, actor)
    end
      
    function DIVINE_ENTITY:getTapNotes(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_TAP, direction, quant) 
    end 
    
    function DIVINE_ENTITY:registerActiveHoldHead(name, actor)    
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_HOLD_HEAD_ACTIVE, name, actor)
    end
    
    function DIVINE_ENTITY:getActiveHoldHeads(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_HOLD_HEAD_ACTIVE, direction, quant)
    end
    
    function DIVINE_ENTITY:registerInactiveHoldHead(name, actor)    
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_HOLD_HEAD_INACTIVE, name, actor)
    end
    
    function DIVINE_ENTITY:getInactiveHoldHeads(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_HOLD_HEAD_INACTIVE, direction, quant)
    end 
    
    function DIVINE_ENTITY:registerActiveRollHead(name, actor)    
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_ROLL_HEAD_ACTIVE, name, actor)
    end
    
    function DIVINE_ENTITY:getActiveRollHeads(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_ROLL_HEAD_ACTIVE, direction, quant)
    end
    
    function DIVINE_ENTITY:registerInactiveRollHead(name, actor)    
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_ROLL_HEAD_INACTIVE, name, actor)
    end
    
    function DIVINE_ENTITY:getInactiveRollHeads(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_ROLL_HEAD_INACTIVE, direction, quant)
    end
    
    function DIVINE_ENTITY:registerExplosion(noteType, name, actor)
        if self.explosions[noteType] == nil then
            self.explosions[noteType] = {}
        end

        self.explosions[noteType][name] = actor
    end
    
    --[[
    This is very similar to getTapNotes but with explosions we have an extra thing to match.
    If I was smart I might refactor these functions in to one (but even then, that might be too
    messy. For now I don't have time so this has to do
    --]]
    function DIVINE_ENTITY:getExplosions(noteType, direction, explosionType, TNS)
        --local direction = direction or ''
        --local explosionType = explosionType or ''
        --local TNS = TNS or ''
        
        local explosions = {}
        local mt = { __index = self.catch }

        setmetatable(explosions, mt)

        --No string.match in Lua 5.0 :[
        --I can think of a really nice way to generalise this idea but I really don't have time to play around implementing it :[
        for name,actor in pairs(self.explosions[noteType]) do
            if direction and explosionType and TNS then                               
                if string.find(name, direction .. ' ' .. noteType .. ' Explosion ' .. explosionType .. ' ' .. TNS) then explosions[name] = actor end
            elseif direction and explosionType then
                if string.find(name, direction) and string.find(name, explosionType) then explosions[name] = actor end
            elseif direction and TNS then
                if string.find(name, direction) and string.find(name, TNS) then explosions[name] = actor end
            elseif explosionType and TNS then
                if string.find(name, TNS) and string.find(name, explosionType) then explosions[name] = actor end
            elseif direction then
                if string.find(name, direction) then explosions[name] = actor end 
            elseif explosionType then
                if string.find(name, explosionType) then explosions[name] = actor end 
            elseif TNS then
                if string.find(name, TNS) then explosions[name] = actor end 
            else
                explosions[name] = actor
            end
        end    

        --I fixed the explosions :]
        return explosions
    end
    
    function DIVINE_ENTITY:registerTapExplosion(name, actor)
        DIVINE_ENTITY:registerExplosion(self.EXPLOSION_NOTE_TYPE_TAP, name, actor)
    end
    
    function DIVINE_ENTITY:getTapExplosions(direction, explosionType, TNS)
        return DIVINE_ENTITY:getExplosions(self.EXPLOSION_NOTE_TYPE_TAP, direction, explosionType, TNS)
    end    
end">
 <children>
  <Actor File='sprites/4th.sprite'
   InitCommand='%function (self)
        DIVINE_ENTITY:registerTapNote("Left Tap Note 4th", self)
        self:rotationz(90);
    end' />
 </children>
</ActorFrame>
