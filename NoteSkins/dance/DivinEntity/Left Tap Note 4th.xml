<ActorFrame
 InitCommand="%function(self)                
    DIVINE_ENTITY = {
        notes={},
        receptors={[PLAYER_1]={}, [PLAYER_2]={}},
        receptorsLookupTable={},
        
        --some constants
        STATE_NEUTRAL = 1,
        STATE_PRESSED = 2,
        NOTE_TYPE_TAP = 'Tap Note',
        NOTE_TYPE_HOLD_HEAD_ACTIVE = 'Hold Head active'
    }

    --[[
    p1's stuff is loaded first. So registerReceptor will always
    be called from p1 first. Therefore it should be sufficient
    to check if we have a actor for p1. If we don't then this
    actor must be p1s, otherwise it is p2s.

    We also put the string value of the actor in a lookup table.
    This way, in the receptor xml files, all we have to do on a pressCommand
    is DIVINE_ENTITY:receptorPressed(self) and we can lookup what arrow that
    actor is, and broadcast accordingly.
    --]]
    function DIVINE_ENTITY:registerReceptor(direction, actor)
    
        --Case 1: P1 _XOR_ P2. We know exactly who the receptors belong to.
        if GAMESTATE:IsPlayerEnabled(PLAYER_1) and not GAMESTATE:IsPlayerEnabled(PLAYER_2) then
            self.receptors[PLAYER_1][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P1' .. direction, state = self.STATE_NEUTRAL}            
            return
        elseif not GAMESTATE:IsPlayerEnabled(PLAYER_1) and GAMESTATE:IsPlayerEnabled(PLAYER_2) then
            self.receptors[PLAYER_2][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P2' .. direction, state = self.STATE_NEUTRAL}
            return
        end
    
        --Case 2: P1 _AND_ P2. We don't know who the arrows belong to, need to be clever.
        if self.receptors[PLAYER_1][direction] == nil then
            self.receptors[PLAYER_1][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P1' .. direction, state = self.STATE_NEUTRAL}
        else
            self.receptors[PLAYER_2][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P2' .. direction, state = self.STATE_NEUTRAL}
        end
    end
    
    function DIVINE_ENTITY:receptorPressed(actor)
        local prefix = self.receptorsLookupTable[tostring(actor)].name
        self.receptorsLookupTable[tostring(actor)].state = self.STATE_PRESSED
        MESSAGEMAN:Broadcast('Step' .. prefix .. 'Pressed')
    end

    function DIVINE_ENTITY:receptorLifted(actor)
        local prefix = self.receptorsLookupTable[tostring(actor)].name
        self.receptorsLookupTable[tostring(actor)].state = self.STATE_NEUTRAL
        MESSAGEMAN:Broadcast('Step' .. prefix .. 'Lifted')
    end

    function DIVINE_ENTITY:isReceptorPressed(direction, player)
        local actor = self.receptors[player][direction]
        return self.receptorsLookupTable[tostring(actor)].state == self.STATE_PRESSED
    end
    
    function DIVINE_ENTITY:getReceptorState(direction, player)
        local actor = self.receptors[player][direction]        
        return self.receptorsLookupTable[tostring(actor)].state
    end
    
    function DIVINE_ENTITY:registerNote (noteType, name, actor)
        if self.notes[noteType] == nil then
            self.notes[noteType] = {}
        end

        self.notes[noteType][name] = actor
    end
	
    function DIVINE_ENTITY:getNotes(noteType, direction, quant)
        direction = direction or ''
        quant = quant or ''

        local function catch(table, key)
            return function(...)
                local paramsToPassOn = {}
            
                tick = 1;
                for i,v in pairs(arg) do
                    if type(v) ~= 'table' then
                        paramsToPassOn[tick] = v
                        tick = tick+1
                    end
                end
             
                for i,v in pairs(arg[1]) do
                    --This is the worst hack ever and I am not proud of it.
                    _G['DivinEntity_f2r'] = v
                    funcstr = '_G[\'DivinEntity_f2r\']:' .. key .. '(\'' .. unpack(paramsToPassOn) .. '\')';
                    assert(loadstring(funcstr))()                                
                end
                
                return table
            end                    
        end
        
        local arrows = {}
        local mt = { __index = catch }

        setmetatable(arrows, mt)

        --No string.match in Lua 5.0 :[
        for name,actor in pairs(self.notes[noteType]) do
            SCREENMAN:SystemMessage(name)
            if direction and quant then                               
                if string.find(name, direction .. ' ' .. noteType .. ' ' .. quant) then arrows[name] = actor end
            elseif direction then
                if string.find(name, direction) then arrows[name] = actor end
            elseif quant then
                if string.find(name, quant) then arrows[name] = actor end 
            else
                arrows[name] = actor
            end
        end    

        return arrows
    end
   
    function DIVINE_ENTITY:registerTapNote(name, actor)
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_TAP, name, actor)
    end
      
    function DIVINE_ENTITY:getTapNotes(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_TAP, direction, quant) 
    end 
    
    function DIVINE_ENTITY:registerActiveHoldHead(name, actor)    
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_HOLD_HEAD_ACTIVE, name, actor)
    end
    
    function DIVINE_ENTITY:getActiveHoldHeads(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_HOLD_HEAD_ACTIVE, direction, quant)
    end   
end">
 <children>
  <Actor File='sprites/4th.sprite'
   InitCommand='%function (self)
        DIVINE_ENTITY:registerTapNote("Left Tap Note 4th", self)
        self:rotationz(90);
    end' />
 </children>
</ActorFrame>
