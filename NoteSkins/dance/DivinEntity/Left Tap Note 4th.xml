<ActorFrame
 InitCommand="%function(self)                
    DIVINE_ENTITY = {
        notes={},
        explosions={},
        receptors={[PLAYER_1]={}, [PLAYER_2]={}},
        receptorsLookupTable={},
        
        --some constants
        STATE_NEUTRAL = 1,
        STATE_PRESSED = 2,
        NOTE_TYPE_TAP = 'Tap Note',
        NOTE_TYPE_HOLD_HEAD_ACTIVE = 'Hold Head active',
        NOTE_TYPE_HOLD_HEAD_INACTIVE = 'Hold Head inactive',
        NOTE_TYPE_ROLL_HEAD_ACTIVE = 'Roll Head active',
        NOTE_TYPE_ROLL_HEAD_INACTIVE = 'Roll Head inactive',
        EXPLOSION_NOTE_TYPE_TAP = 'Tap',
    }
    
    --This function makes the fluent magic happen in getTapNotes and getExplosions.
    function DIVINE_ENTITY.catch(table, key)
        return function(...)
            local paramsToPassOn = {}
        
            tick = 1;
            for i,v in pairs(arg) do
                if type(v) ~= 'table' then
                    paramsToPassOn[tick] = v
                    tick = tick+1
                end
            end
         
            for i,v in pairs(arg[1]) do
                --This is the worst hack ever and I am not proud of it.
                _G['DivinEntity_f2r'] = v
                funcstr = '_G[\'DivinEntity_f2r\']:' .. key .. '(\'' .. unpack(paramsToPassOn) .. '\')';
                assert(loadstring(funcstr))()                                
            end
            
            return table
        end                    
    end

    --[[
    p1's stuff is loaded first. So registerReceptor will always
    be called from p1 first. Therefore it should be sufficient
    to check if we have a actor for p1. If we don't then this
    actor must be p1s, otherwise it is p2s.

    We also put the string value of the actor in a lookup table.
    This way, in the receptor xml files, all we have to do on a pressCommand
    is DIVINE_ENTITY:receptorPressed(self) and we can lookup what arrow that
    actor is, and broadcast accordingly.
    --]]
    function DIVINE_ENTITY:registerReceptor(direction, actor)
    
        --Case 1: P1 _XOR_ P2. We know exactly who the receptors belong to.
        if GAMESTATE:IsPlayerEnabled(PLAYER_1) and not GAMESTATE:IsPlayerEnabled(PLAYER_2) then
            self.receptors[PLAYER_1][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P1' .. direction, state = self.STATE_NEUTRAL}            
            return
        elseif not GAMESTATE:IsPlayerEnabled(PLAYER_1) and GAMESTATE:IsPlayerEnabled(PLAYER_2) then
            self.receptors[PLAYER_2][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P2' .. direction, state = self.STATE_NEUTRAL}
            return
        end
    
        --Case 2: P1 _AND_ P2. We don't know who the arrows belong to, need to be clever.
        if self.receptors[PLAYER_1][direction] == nil then
            self.receptors[PLAYER_1][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P1' .. direction, state = self.STATE_NEUTRAL}
        else
            self.receptors[PLAYER_2][direction] = actor
            self.receptorsLookupTable[tostring(actor)] = {name = 'P2' .. direction, state = self.STATE_NEUTRAL}
        end
    end
    
    function DIVINE_ENTITY:receptorPressed(actor)
        local prefix = self.receptorsLookupTable[tostring(actor)].name
        self.receptorsLookupTable[tostring(actor)].state = self.STATE_PRESSED
        MESSAGEMAN:Broadcast('Step' .. prefix .. 'Pressed')
    end

    function DIVINE_ENTITY:receptorLifted(actor)
        local prefix = self.receptorsLookupTable[tostring(actor)].name
        self.receptorsLookupTable[tostring(actor)].state = self.STATE_NEUTRAL
        MESSAGEMAN:Broadcast('Step' .. prefix .. 'Lifted')
    end

    function DIVINE_ENTITY:isReceptorPressed(direction, player)
        local actor = self.receptors[player][direction]
        return self.receptorsLookupTable[tostring(actor)].state == self.STATE_PRESSED
    end
    
    function DIVINE_ENTITY:getReceptorState(direction, player)
        local actor = self.receptors[player][direction]        
        return self.receptorsLookupTable[tostring(actor)].state
    end
    
    function DIVINE_ENTITY:registerNote (noteType, name, actor)
        if self.notes[noteType] == nil then
            self.notes[noteType] = {}
        end

        self.notes[noteType][name] = actor
    end
	
    function DIVINE_ENTITY:getNotes(noteType, direction, quant)
        local direction = direction or ''
        local quant = quant or ''
        
        local arrows = {}
        local mt = { __index = self.catch }

        setmetatable(arrows, mt)

        --No string.match in Lua 5.0 :[
        for name,actor in pairs(self.notes[noteType]) do
            if direction and quant then
                if string.find(name, direction .. ' ' .. noteType .. ' ' .. quant) then arrows[name] = actor end
            end
        end    

        return arrows
    end
       
    function DIVINE_ENTITY:registerTapNote(name, actor)
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_TAP, name, actor)
    end
      
    function DIVINE_ENTITY:getTapNotes(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_TAP, direction, quant) 
    end 
    
    function DIVINE_ENTITY:registerActiveHoldHead(name, actor)    
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_HOLD_HEAD_ACTIVE, name, actor)
    end
    
    function DIVINE_ENTITY:getActiveHoldHeads(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_HOLD_HEAD_ACTIVE, direction, quant)
    end
    
    function DIVINE_ENTITY:registerInactiveHoldHead(name, actor)    
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_HOLD_HEAD_INACTIVE, name, actor)
    end
    
    function DIVINE_ENTITY:getInactiveHoldHeads(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_HOLD_HEAD_INACTIVE, direction, quant)
    end 
    
    function DIVINE_ENTITY:registerActiveRollHead(name, actor)    
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_ROLL_HEAD_ACTIVE, name, actor)
    end
    
    function DIVINE_ENTITY:getActiveRollHeads(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_ROLL_HEAD_ACTIVE, direction, quant)
    end
    
    function DIVINE_ENTITY:registerInactiveRollHead(name, actor)    
        DIVINE_ENTITY:registerNote(self.NOTE_TYPE_ROLL_HEAD_INACTIVE, name, actor)
    end
    
    function DIVINE_ENTITY:getInactiveRollHeads(direction, quant)
        return DIVINE_ENTITY:getNotes(self.NOTE_TYPE_ROLL_HEAD_INACTIVE, direction, quant)
    end
    
    function DIVINE_ENTITY:registerExplosion(noteType, name, actor)
        if self.explosions[noteType] == nil then
            self.explosions[noteType] = {}
        end

        self.explosions[noteType][name] = actor
    end
    
    --[[
    This is very similar to getTapNotes but with explosions we have an extra thing to match.
    If I was smart I might refactor these functions in to one (but even then, that might be too
    messy. For now I don't have time so this has to do
    --]]
    function DIVINE_ENTITY:getExplosions(noteType, direction, explosionType, TNS)
        --local direction = direction or ''
        --local explosionType = explosionType or ''
        --local TNS = TNS or ''
        
        local explosions = {}
        local mt = { __index = self.catch }

        setmetatable(explosions, mt)

        --No string.match in Lua 5.0 :[
        --I can think of a really nice way to generalise this idea but I really don't have time to play around implementing it :[
        for name,actor in pairs(self.explosions[noteType]) do
            if direction and explosionType and TNS then                               
                if string.find(name, direction .. ' ' .. noteType .. ' Explosion ' .. explosionType .. ' ' .. TNS) then explosions[name] = actor end
            elseif direction and explosionType then
                if string.find(name, direction) and string.find(name, explosionType) then explosions[name] = actor end
            elseif direction and TNS then
                if string.find(name, direction) and string.find(name, TNS) then explosions[name] = actor end
            elseif explosionType and TNS then
                if string.find(name, TNS) and string.find(name, explosionType) then explosions[name] = actor end
            elseif direction then
                if string.find(name, direction) then explosions[name] = actor end 
            elseif explosionType then
                if string.find(name, explosionType) then explosions[name] = actor end 
            elseif TNS then
                if string.find(name, TNS) then explosions[name] = actor end 
            else
                explosions[name] = actor
            end
        end    

        --I fixed the explosions :]
        return explosions
    end
    
    function DIVINE_ENTITY:registerTapExplosion(name, actor)
        DIVINE_ENTITY:registerExplosion(self.EXPLOSION_NOTE_TYPE_TAP, name, actor)
    end
    
    function DIVINE_ENTITY:getTapExplosions(direction, explosionType, TNS)
        return DIVINE_ENTITY:getExplosions(self.EXPLOSION_NOTE_TYPE_TAP, direction, explosionType, TNS)
    end    
end">
 <children>
  <Actor File='sprites/4th.sprite'
   InitCommand='%function (self)
        DIVINE_ENTITY:registerTapNote("Left Tap Note 4th", self)
        self:rotationz(90);
    end' />
 </children>
</ActorFrame>
